{"version":3,"sources":["../src/utilities.js"],"names":["self","module","exports","dataMap","version","books","notes","tree","localDb","unsupportedCharacters","win32","linux","darwin","getBackupPath","inkdrop","config","get","core","db","backupPath","getPlainTextPath","getDataMapPath","plainTextPath","getNotePath","removeUnsupportedCharacters","fileName","replace","RegExp","process","platform","getDataMap","JSON","parse","fs","promises","readFile","migrationRemoveUnsupportedFileNames","access","tempMap","directories","readdir","directory","rmdir","recursive","ignore","writeNote","notePath","body","mkdir","path","dirname","writeFile","getBookPath","doc","bookPath","name","parentBookId","hasParent","parentBookData","supportedParentBookName","Boolean","getDataAndWriteAllNotes","packageInfo","allNotes","all","limit","Promise","resolve","reject","docs","map","_id","title","bookData","bookId","supportedDocTitle","getTree","dirPath","arrayOfFiles","files","readdirSync","forEach","file","filePath","statSync","isDirectory","extname","push","writeMaps","maps","dataMapPath","stringify","importAll","diskDataMap","main","dataStore","getLocalDB","Object","keys","noteId","fileTreeIndex","indexOf","splice","newBody","currentNote","put","_rev","updatedAt","Date","now","doctype","createdAt","err","console","warn","prunedTree","filter","test","notebooks","notebooksSupportedName","notebook","newNotePath","bookPathArray","split","pop","newNoteId","createId","basename"],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as packageInfo from \"../package.json\";\n\nconst self = (module.exports = {\n    dataMap: { version: \"\", books: {}, notes: {}, tree: [] },\n    localDb: null,\n    unsupportedCharacters: {\n        win32: /[<>:\"\\/\\\\|\\?*]/,\n        linux: /[\\/]/,\n        darwin: /[:\\/]/,\n    },\n\n    getBackupPath() {\n        return inkdrop.config.get().core.db.backupPath;\n    },\n    getPlainTextPath(backupPath) {\n        return `${backupPath || self.getBackupPath()}/PLAIN_TEXT`;\n    },\n    getDataMapPath(plainTextPath) {\n        return `${\n            plainTextPath || self.getPlainTextPath()\n        }/.inkdrop_plain_text_backups/__DATA_MAP__.json`;\n    },\n    getNotePath() {},\n    removeUnsupportedCharacters(fileName) {\n        return fileName.replace(\n            new RegExp(this.unsupportedCharacters[process.platform], \"g\"),\n            \"\"\n        );\n    },\n    async getDataMap(plainTextPath) {\n        return JSON.parse(\n            await fs.promises.readFile(\n                self.getDataMapPath(plainTextPath),\n                \"utf-8\"\n            )\n        );\n    },\n    async migrationRemoveUnsupportedFileNames(plainTextPath) {\n        try {\n            await fs.promises.access(self.getDataMapPath(plainTextPath));\n\n            const tempMap = await self.getDataMap(plainTextPath);\n            if (tempMap && tempMap.version) {\n                return;\n            }\n            const directories = await fs.promises.readdir(plainTextPath);\n            for (const directory of directories) {\n                await fs.promises.rmdir(`${plainTextPath}/${directory}`, {\n                    recursive: true,\n                });\n            }\n        } catch (ignore) {}\n    },\n\n    async writeNote(notePath, body) {\n        await fs.promises.mkdir(path.dirname(notePath), { recursive: true });\n        await fs.promises.writeFile(notePath, body);\n    },\n    async getBookPath(localDb, doc) {\n        let bookPath = self.removeUnsupportedCharacters(doc.name);\n        if (doc.parentBookId) {\n            let hasParent = true;\n            while (hasParent) {\n                var parentBookData = await localDb.books.get(\n                    parentBookData\n                        ? parentBookData.parentBookId\n                        : doc.parentBookId\n                );\n                const supportedParentBookName =\n                    self.removeUnsupportedCharacters(parentBookData.name);\n                bookPath = `${supportedParentBookName}/${bookPath}`;\n                hasParent = Boolean(parentBookData.parentBookId);\n            }\n        }\n        return bookPath;\n    },\n    async getDataAndWriteAllNotes(localDb, plainTextPath) {\n        // Sync everything one time:\n        await self.migrationRemoveUnsupportedFileNames(plainTextPath);\n        self.dataMap.version = packageInfo.version;\n        const allNotes = await localDb.notes.all({ limit: 999999 });\n\n        return new Promise(async (resolve, reject) => {\n            await Promise.all(\n                await allNotes.docs.map(async (doc) => {\n                    if (!self.dataMap.notes[doc._id]) {\n                        self.dataMap.notes[doc._id] = {};\n                    }\n                    self.dataMap.notes[doc._id].title = doc.title;\n\n                    const bookData = await localDb.books.get(doc.bookId);\n\n                    if (bookData) {\n                        let bookPath = await self.getBookPath(\n                            localDb,\n                            bookData\n                        );\n\n                        const supportedDocTitle =\n                            self.removeUnsupportedCharacters(doc.title);\n                        self.dataMap.books[doc.bookId] = bookPath;\n                        self.dataMap.notes[\n                            doc._id\n                        ].path = `${bookPath}/${supportedDocTitle}.md`;\n\n                        await self.writeNote(\n                            `${plainTextPath}/${\n                                self.dataMap.notes[doc._id].path\n                            }`,\n                            doc.body\n                        );\n                    }\n                })\n            );\n            if (self.dataMap) {\n                resolve(self.dataMap);\n            } else {\n                reject(self);\n            }\n        });\n    },\n    getTree: (dirPath, arrayOfFiles) => {\n        const files = fs.readdirSync(dirPath);\n\n        arrayOfFiles = arrayOfFiles || [];\n\n        files.forEach(function (file) {\n            const filePath = `${dirPath}/${file}`;\n            if (fs.statSync(filePath).isDirectory()) {\n                arrayOfFiles = self.getTree(filePath, arrayOfFiles);\n            } else if (path.extname(file) === \".md\") {\n                arrayOfFiles.push(filePath);\n            }\n        });\n\n        return arrayOfFiles;\n    },\n    async writeMaps(plainTextPath, maps) {\n        maps.tree = self.getTree(plainTextPath);\n        const dataMapPath = self.getDataMapPath(plainTextPath);\n        await fs.promises.mkdir(path.dirname(dataMapPath), { recursive: true });\n\n        await fs.promises.writeFile(dataMapPath, JSON.stringify(maps));\n    },\n\n    async importAll() {\n        const plainTextPath = self.getPlainTextPath();\n        const diskDataMap = await self.getDataMap(plainTextPath);\n        self.localDb = self.localDb || inkdrop.main.dataStore.getLocalDB();\n\n        const tree = self.getTree(plainTextPath);\n\n        await Promise.all(\n            Object.keys(diskDataMap.notes).map(async (noteId) => {\n                const filePath = `${plainTextPath}/${diskDataMap.notes[noteId].path}`;\n                const fileTreeIndex = tree.indexOf(filePath);\n                if (fileTreeIndex > -1) {\n                    tree.splice(fileTreeIndex, 1);\n                }\n                const newBody = await fs.promises.readFile(filePath, \"utf-8\");\n\n                try {\n                    const currentNote = await self.localDb.notes.get(noteId);\n\n                    // Don't bother if there are no changes:\n                    if (currentNote.body !== newBody) {\n                        await self.localDb.notes.put({\n                            _id: noteId,\n                            _rev: currentNote._rev,\n                            updatedAt: Date.now(),\n                            bookId: currentNote.bookId,\n                            title: currentNote.title,\n                            doctype: currentNote.doctype,\n                            createdAt: currentNote.createdAt,\n                            body: newBody,\n                        });\n                    }\n                } catch (err) {\n                    console.warn(\n                        `${noteId} import from plain text failed!`,\n                        err\n                    );\n                }\n            })\n        );\n\n        // Remove 'Trash' files from the tree:\n        const prunedTree = tree.filter((filePath) => {\n            return !new RegExp(`${plainTextPath}/undefined/`).test(filePath);\n        });\n\n        const notebooks = await self.localDb.books.all({ limit: 999999 });\n        let notebooksSupportedName = {};\n        notebooks.map((notebook) => {\n            notebooksSupportedName[\n                self.removeUnsupportedCharacters(notebook.name)\n            ] = notebook._id;\n        });\n\n        await Promise.all(\n            prunedTree.map(async (newNotePath) => {\n                const bookPathArray = path\n                    .dirname(newNotePath)\n                    .replace(new RegExp(`^${plainTextPath}/`), \"\")\n                    .split(\"/\");\n                // This is a best guess because it uses the name,\n                // if there is another notebook with the same\n                // exact name this may return the\n                // 'wrong' one.\n                const bookId = notebooksSupportedName[bookPathArray.pop()];\n                if (bookId) {\n                    const newBody = await fs.promises.readFile(\n                        newNotePath,\n                        \"utf-8\"\n                    );\n\n                    const newNoteId = self.localDb.notes.createId();\n                    await self.localDb.notes.put({\n                        _id: newNoteId,\n                        updatedAt: Date.now(),\n                        bookId: bookId,\n                        title: path\n                            .basename(newNotePath)\n                            .replace(\n                                new RegExp(`${path.extname(newNotePath)}$`),\n                                \"\"\n                            ),\n                        doctype: \"markdown\",\n                        createdAt: Date.now(),\n                        body: newBody,\n                    });\n                }\n            })\n        );\n\n        await self.writeMaps(plainTextPath, self.dataMap);\n    },\n});\n"],"file":"utilities.js"}